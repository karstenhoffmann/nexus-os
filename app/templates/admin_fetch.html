{% extends "base.html" %}
{% from "macros/icons.html" import icon %}
{% block content %}

<h1 class="text-2xl font-bold mb-6">Fulltext Fetching</h1>

<div x-data="fetchApp()" x-init="init()" class="space-y-6">

  <!-- Stats Overview -->
  <div class="stats stats-vertical md:stats-horizontal shadow-md bg-base-100 w-full">
    <div class="stat">
      <div class="stat-title">Dokumente</div>
      <div class="stat-value">{{ stats.total }}</div>
      <div class="stat-desc">{{ stats.with_url }} mit URL</div>
    </div>
    <div class="stat">
      <div class="stat-title">Mit Fulltext</div>
      <div class="stat-value text-success" x-text="withFulltext">{{ stats.with_fulltext }}</div>
      <div class="stat-desc">bereit für Chunks</div>
    </div>
    <div class="stat">
      <div class="stat-title">Ausstehend</div>
      <div class="stat-value text-warning" x-text="pending">{{ stats.pending }}</div>
      <div class="stat-desc">warten auf Fetch</div>
    </div>
    <div class="stat">
      <div class="stat-title">Fehlgeschlagen</div>
      <div class="stat-value" :class="failed > 0 ? 'text-error' : 'text-base-content/30'" x-text="failed">{{ stats.failed }}</div>
      <div class="stat-desc">ggf. retry-fähig</div>
    </div>
  </div>

  <!-- Resume Banner -->
  {% if resumable_job %}
  <div role="alert" class="alert alert-warning" x-show="!jobId || jobId !== '{{ resumable_job.id }}'">
    {{ icon("alert-triangle") }}
    <div>
      <h3 class="font-bold">Unterbrochener Job gefunden</h3>
      <div class="text-sm">
        {{ resumable_job.status.value }} · {{ resumable_job.items_processed }}/{{ resumable_job.items_total or '?' }} verarbeitet · {{ resumable_job.items_succeeded }} OK · {{ resumable_job.items_failed }} Fehler
      </div>
    </div>
    <div class="flex gap-2">
      <button @click="resumeJob('{{ resumable_job.id }}')" class="btn btn-sm btn-primary">
        {{ icon("play") }} Fortsetzen
      </button>
      <button @click="dismissResume()" class="btn btn-sm btn-ghost">
        Ignorieren
      </button>
    </div>
  </div>
  {% endif %}

  <!-- Running Job Status -->
  {% if running_job %}
  <div role="alert" class="alert alert-info">
    {{ icon("loader", "animate-spin") }}
    <div class="flex-1">
      <h3 class="font-bold">Job läuft</h3>
      <div class="text-sm">ID: {{ running_job.id[:8] }} · {{ running_job.items_processed }}/{{ running_job.items_total or '?' }}</div>
      <progress class="progress progress-primary w-full mt-2" value="{{ running_job.progress_percent }}" max="100"></progress>
    </div>
  </div>
  {% endif %}

  <!-- Control Card -->
  <div class="card bg-base-100 shadow-md">
    <div class="card-body">
      <h2 class="card-title">Steuerung</h2>

      <div class="flex flex-wrap items-center gap-4 text-sm">
        <div>
          <span class="font-medium">Status:</span>
          <span class="ml-1" :class="{
            'text-success': status === 'completed',
            'text-error': status === 'failed' || status === 'error',
            'text-warning': status === 'paused'
          }" x-text="status"></span>
        </div>
        <div x-show="itemsTotal > 0">
          <span class="font-medium">Fortschritt:</span>
          <span x-text="itemsProcessed + ' / ' + itemsTotal"></span>
          (<span x-text="Math.round(progressPercent)"></span>%)
        </div>
      </div>

      <!-- Progress Bar (div-based for reliable binding) -->
      <div class="w-full bg-base-300 rounded-full h-3 my-4">
        <div class="bg-primary h-3 rounded-full transition-all" :style="'width: ' + progressPercent + '%'"></div>
      </div>

      <!-- Counters as Badges (colored only when non-zero) -->
      <div class="flex flex-wrap gap-2 mb-4">
        <span class="badge gap-1" :class="itemsSucceeded > 0 ? 'badge-success' : 'badge-ghost'">
          <span x-text="itemsSucceeded"></span> Erfolg
        </span>
        <span class="badge gap-1" :class="itemsFailed > 0 ? 'badge-error' : 'badge-ghost'">
          <span x-text="itemsFailed"></span> Fehler
        </span>
        <span class="badge badge-ghost gap-1">
          <span x-text="itemsSkipped"></span> Übersprungen
        </span>
      </div>

      <!-- Buttons -->
      <div class="card-actions">
        <button
          @click="startFetch()"
          class="btn btn-primary"
          :disabled="status === 'running'"
          x-show="status !== 'running' && status !== 'paused'">
          {{ icon("download") }} Fetch starten
        </button>
        <button
          @click="pauseFetch()"
          class="btn btn-warning"
          x-show="status === 'running'">
          {{ icon("pause") }} Pausieren
        </button>
        <button
          @click="resumeFetch()"
          class="btn btn-outline"
          x-show="status === 'paused'">
          {{ icon("play") }} Fortsetzen
        </button>
        <button
          @click="cancelFetch()"
          class="btn btn-error"
          x-show="status === 'running' || status === 'paused'">
          {{ icon("x-circle") }} Abbrechen
        </button>
      </div>
    </div>
  </div>

  <!-- Next Steps Card (only show when there's work to do) -->
  {% if stats.without_chunks > 0 %}
  <div class="card bg-base-100 shadow-md" x-data="{ chunkLoading: false, chunkResult: null, ftsLoading: false, ftsResult: null }">
    <div class="card-body">
      <h2 class="card-title text-base">Nächste Schritte</h2>
      <div class="flex flex-wrap items-center gap-4">
        <button
          class="btn btn-secondary btn-sm whitespace-nowrap"
          :disabled="chunkLoading"
          @click="
            chunkLoading = true;
            chunkResult = null;
            fetch('/api/embeddings/generate-chunks?limit=500', { method: 'POST' })
              .then(r => r.json())
              .then(data => { chunkResult = data; chunkLoading = false; })
              .catch(e => { chunkResult = { error: e.message }; chunkLoading = false; })
          ">
          <span x-show="!chunkLoading" class="inline-flex items-center gap-1">{{ icon("zap") }} {{ stats.without_chunks }} Dokumente chunken</span>
          <span x-show="chunkLoading" class="loading loading-spinner loading-xs"></span>
        </button>
        <button
          class="btn btn-ghost btn-sm whitespace-nowrap"
          :disabled="ftsLoading"
          @click="
            ftsLoading = true;
            ftsResult = null;
            fetch('/admin/fts/rebuild', { method: 'POST' })
              .then(r => r.json())
              .then(data => { ftsResult = data; ftsLoading = false; })
              .catch(e => { ftsResult = { error: e.message }; ftsLoading = false; })
          ">
          <span x-show="!ftsLoading" class="inline-flex items-center gap-1">{{ icon("refresh-cw") }} FTS neu bauen</span>
          <span x-show="ftsLoading" class="loading loading-spinner loading-xs"></span>
        </button>
      </div>
      <p x-show="chunkResult && !chunkResult.error" class="text-sm text-success">
        <span x-text="chunkResult?.chunks_created || 0"></span> Chunks, <span x-text="chunkResult?.processed || 0"></span> Embeddings erstellt
      </p>
      <p x-show="chunkResult?.error" class="text-sm text-error" x-text="chunkResult?.error"></p>
      <p x-show="ftsResult && !ftsResult.error" class="text-sm text-success" x-text="ftsResult?.message"></p>
      <p x-show="ftsResult?.error" class="text-sm text-error" x-text="ftsResult?.error"></p>
    </div>
  </div>
  {% endif %}

  <!-- Error Display -->
  <div role="alert" class="alert alert-error" x-show="errorMsg" x-cloak>
    {{ icon("alert-circle") }}
    <span><strong>Fehler:</strong> <span x-text="errorMsg"></span></span>
  </div>

  <!-- Failure Summary -->
  {% if failure_summary %}
  <div class="card bg-base-100 shadow-md">
    <div class="card-body">
      <h2 class="card-title">Fehler-Zusammenfassung</h2>
      <div class="flex flex-wrap gap-2">
        {% for error_type, count in failure_summary.items() %}
        <span class="badge badge-error badge-lg gap-2">
          <span class="font-bold">{{ count }}</span>
          <span>{{ error_type }}</span>
        </span>
        {% endfor %}
      </div>
      <div class="card-actions mt-4">
        <button @click="retryFailed()" class="btn btn-outline btn-sm">
          {{ icon("refresh-cw") }} Retry-fähige zurücksetzen
        </button>
        <span class="text-xs text-base-content/50">(timeout, http_5xx)</span>
      </div>
    </div>
  </div>
  {% endif %}

  <!-- Live Log -->
  <div class="card bg-base-100 shadow-md">
    <div class="card-body">
      <h2 class="card-title text-base">Live Log</h2>
      <div x-show="log.length === 0" class="text-sm text-base-content/40 italic">
        Noch keine Aktivität.
      </div>
      <div x-show="log.length > 0" class="border border-base-300 rounded-lg p-3 max-h-60 overflow-y-auto font-mono text-xs" x-ref="logContainer">
        <template x-for="(entry, index) in log" :key="index">
          <div class="py-0.5" :class="{
            'text-success': entry.type === 'item_success' || entry.type === 'completed',
            'text-error': entry.type === 'item_failed' || entry.type === 'failed' || entry.type === 'error',
            'text-warning': entry.type === 'paused' || entry.type === 'cancelled',
            'text-base-content/50': entry.type === 'item_skipped'
          }">
            <span class="text-base-content/40" x-text="entry.time"></span>
            <span x-text="entry.msg"></span>
          </div>
        </template>
      </div>
    </div>
  </div>

  <!-- Recent Jobs -->
  <div class="card bg-base-100 shadow-md">
    <div class="card-body">
      <h2 class="card-title">Vorherige Jobs</h2>
      {% if jobs %}
      <div class="space-y-3">
        {% for job in jobs %}
        <div class="bg-base-200 rounded-lg p-3">
          <div class="flex justify-between items-center mb-2">
            <code class="text-sm font-bold">{{ job.id[:8] }}</code>
            <span class="badge badge-sm {% if job.status.value == 'completed' %}badge-success{% elif job.status.value == 'running' %}badge-info{% elif job.status.value == 'paused' %}badge-warning{% elif job.status.value == 'failed' %}badge-error{% else %}badge-ghost{% endif %}">
              {{ job.status.value }}
            </span>
          </div>
          <div class="flex flex-wrap gap-3 text-sm text-base-content/70 mb-2">
            <span>{{ job.items_succeeded }} Erfolg</span>
            <span>{{ job.items_failed }} Fehler</span>
            <span>{{ job.items_skipped }} Skip</span>
            <span class="ml-auto">{{ job.last_activity.strftime('%d.%m. %H:%M') }}</span>
          </div>
          <progress class="progress progress-primary w-full h-1" value="{{ job.progress_percent }}" max="100"></progress>
        </div>
        {% endfor %}
      </div>
      {% else %}
      <p class="text-base-content/50">Keine Jobs vorhanden.</p>
      {% endif %}
    </div>
  </div>

</div>

<style>
[x-cloak] { display: none !important; }
</style>

<script>
function fetchApp() {
  return {
    jobId: null,
    status: 'idle',
    itemsProcessed: 0,
    itemsSucceeded: 0,
    itemsFailed: 0,
    itemsSkipped: 0,
    itemsTotal: {{ stats.pending }},
    progressPercent: 0,
    errorMsg: '',
    log: [],
    eventSource: null,
    // Live stats
    withFulltext: {{ stats.with_fulltext }},
    pending: {{ stats.pending }},
    failed: {{ stats.failed }},

    init() {
      // Check for running job
      {% if running_job %}
      this.jobId = '{{ running_job.id }}';
      this.status = 'running';
      this.itemsProcessed = {{ running_job.items_processed }};
      this.itemsSucceeded = {{ running_job.items_succeeded }};
      this.itemsFailed = {{ running_job.items_failed }};
      this.itemsSkipped = {{ running_job.items_skipped }};
      this.itemsTotal = {{ running_job.items_total or 0 }};
      this.progressPercent = {{ running_job.progress_percent }};
      this.connectStream();
      {% endif %}
    },

    addLog(type, msg, icon = '') {
      const now = new Date();
      const time = now.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      this.log.unshift({ type, msg, time, icon });
      // Limit log size
      if (this.log.length > 100) {
        this.log = this.log.slice(0, 100);
      }
    },

    async startFetch() {
      this.status = 'starting';
      this.errorMsg = '';
      this.log = [];
      this.itemsProcessed = 0;
      this.itemsSucceeded = 0;
      this.itemsFailed = 0;
      this.itemsSkipped = 0;

      try {
        const resp = await fetch('/api/fetch/start', { method: 'POST' });
        const data = await resp.json();

        if (data.error) {
          this.errorMsg = data.error;
          this.status = 'error';
          return;
        }

        this.jobId = data.job_id;
        this.itemsTotal = data.items_total;
        this.addLog('started', 'Job gestartet: ' + this.jobId.substring(0, 8), '');
        this.connectStream();

      } catch (e) {
        this.status = 'error';
        this.errorMsg = 'Fehler beim Starten: ' + e.message;
      }
    },

    connectStream() {
      if (this.eventSource) {
        this.eventSource.close();
      }

      const url = '/api/fetch/' + this.jobId + '/stream';
      this.eventSource = new EventSource(url);
      this.status = 'running';

      this.eventSource.addEventListener('started', (e) => {
        const data = JSON.parse(e.data);
        this.addLog('started', 'Fetch gestartet', '');
      });

      this.eventSource.addEventListener('item_success', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.addLog('item_success', data.title + ' (' + data.char_count + ' Zeichen)', '');
        this.withFulltext++;
        this.pending--;
      });

      this.eventSource.addEventListener('item_failed', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.addLog('item_failed', data.title + ' - ' + data.error_type, '');
        this.failed++;
        this.pending--;
      });

      this.eventSource.addEventListener('item_skipped', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.addLog('item_skipped', data.title + ' (' + data.reason + ')', '');
        this.pending--;
      });

      this.eventSource.addEventListener('progress', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
      });

      this.eventSource.addEventListener('paused', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.status = 'paused';
        this.addLog('paused', 'Job pausiert', '');
        this.eventSource.close();
      });

      this.eventSource.addEventListener('completed', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.status = 'completed';
        this.addLog('completed', 'Fetch abgeschlossen: ' + this.itemsSucceeded + ' Erfolg, ' + this.itemsFailed + ' Fehler', '');
        this.eventSource.close();
      });

      this.eventSource.addEventListener('failed', (e) => {
        const data = JSON.parse(e.data);
        this.status = 'failed';
        this.errorMsg = data.error || 'Unbekannter Fehler';
        this.addLog('failed', 'Job fehlgeschlagen: ' + this.errorMsg, '');
        this.eventSource.close();
      });

      this.eventSource.addEventListener('cancelled', (e) => {
        this.status = 'cancelled';
        this.addLog('cancelled', 'Job abgebrochen', '');
        this.eventSource.close();
      });

      this.eventSource.addEventListener('error', (e) => {
        if (e.data) {
          const data = JSON.parse(e.data);
          this.errorMsg = data.error;
          this.addLog('error', 'Fehler: ' + data.error, '');
        }
        this.status = 'error';
        this.eventSource.close();
      });

      this.eventSource.onerror = () => {
        if (this.status === 'running') {
          this.status = 'error';
          this.addLog('error', 'Verbindung verloren', '');
        }
        this.eventSource.close();
      };
    },

    updateFromData(data) {
      this.itemsProcessed = data.items_processed || this.itemsProcessed;
      this.itemsSucceeded = data.items_succeeded || this.itemsSucceeded;
      this.itemsFailed = data.items_failed || this.itemsFailed;
      this.itemsSkipped = data.items_skipped || this.itemsSkipped;
      this.progressPercent = data.progress_percent || this.progressPercent;
    },

    async pauseFetch() {
      if (!this.jobId) return;
      try {
        await fetch('/api/fetch/' + this.jobId + '/pause', { method: 'POST' });
        this.addLog('paused', 'Pause angefordert...', '');
      } catch (e) {
        this.errorMsg = 'Fehler beim Pausieren: ' + e.message;
      }
    },

    async resumeFetch() {
      if (!this.jobId) return;
      try {
        await fetch('/api/fetch/' + this.jobId + '/resume', { method: 'POST' });
        this.addLog('progress', 'Fortsetzen...', '');
        this.connectStream();
      } catch (e) {
        this.errorMsg = 'Fehler beim Fortsetzen: ' + e.message;
      }
    },

    async resumeJob(previousJobId) {
      this.jobId = previousJobId;
      this.status = 'resuming';
      this.errorMsg = '';
      this.log = [];

      try {
        await fetch('/api/fetch/' + previousJobId + '/resume', { method: 'POST' });
        this.addLog('progress', 'Fortsetzen von Job ' + previousJobId.substring(0, 8) + '...', '');
        this.connectStream();
      } catch (e) {
        this.errorMsg = 'Fehler beim Fortsetzen: ' + e.message;
        this.status = 'error';
      }
    },

    async cancelFetch() {
      if (!this.jobId) return;
      try {
        await fetch('/api/fetch/' + this.jobId + '/cancel', { method: 'POST' });
        this.status = 'cancelled';
        this.addLog('cancelled', 'Job abgebrochen', '');
        if (this.eventSource) {
          this.eventSource.close();
        }
      } catch (e) {
        this.errorMsg = 'Fehler beim Abbrechen: ' + e.message;
      }
    },

    async retryFailed() {
      try {
        const resp = await fetch('/api/fetch/retry-failed', { method: 'POST' });
        const data = await resp.json();
        this.addLog('progress', data.cleared + ' Fehler zurueckgesetzt', '');
        // Refresh stats
        const statsResp = await fetch('/api/fetch/stats');
        const stats = await statsResp.json();
        this.pending = stats.pending;
        this.failed = stats.failed;
      } catch (e) {
        this.errorMsg = 'Fehler: ' + e.message;
      }
    },

    dismissResume() {
      // Simply set a flag - the x-show will handle hiding
      this.jobId = 'dismissed';
    }
  };
}
</script>

{% endblock %}
