{% extends "base.html" %}
{% block content %}

<h1>Embedding Generator</h1>

<div x-data="embedApp()" x-init="init()">

  <!-- Pipeline Explanation -->
  <div class="card info-card">
    <h2>Was sind Embeddings?</h2>
    <p>
      Embeddings wandeln Text in Zahlen-Vektoren um, damit die <strong>semantische Suche</strong> funktioniert.
      Statt nur nach exakten Worten zu suchen, findet die Suche dann auch inhaltlich verwandte Texte.
    </p>
    <div class="pipeline">
      <div class="pipeline-step">
        <div class="step-icon">1</div>
        <div class="step-text">
          <strong>Import</strong>
          <span>Dokumente aus Readwise</span>
        </div>
      </div>
      <div class="pipeline-arrow">→</div>
      <div class="pipeline-step">
        <div class="step-icon">2</div>
        <div class="step-text">
          <strong>Chunking</strong>
          <span>Aufteilung in ~800 Zeichen</span>
        </div>
      </div>
      <div class="pipeline-arrow">→</div>
      <div class="pipeline-step current">
        <div class="step-icon">3</div>
        <div class="step-text">
          <strong>Embedding</strong>
          <span>Vektoren via OpenAI</span>
        </div>
      </div>
      <div class="pipeline-arrow">→</div>
      <div class="pipeline-step">
        <div class="step-icon">4</div>
        <div class="step-text">
          <strong>Suche</strong>
          <span>Semantisch durchsuchbar</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Status Overview -->
  <div class="card">
    <h2>Status</h2>

    <!-- All Done Banner -->
    <div class="status-banner status-success" x-show="pendingChunks === 0 && stats.total_chunks > 0">
      <div class="status-icon"><i data-feather="check-circle"></i></div>
      <div class="status-text">
        <strong>Alle Chunks haben Embeddings!</strong>
        <span>Semantische Suche ist vollstaendig einsatzbereit.</span>
      </div>
    </div>

    <!-- Pending Banner -->
    <div class="status-banner status-pending" x-show="pendingChunks > 0">
      <div class="status-icon"><i data-feather="clock"></i></div>
      <div class="status-text">
        <strong x-text="pendingChunks.toLocaleString() + ' Chunks ohne Embedding'"></strong>
        <span>Diese Chunks sind noch nicht semantisch durchsuchbar.</span>
      </div>
    </div>

    <!-- No Chunks Banner -->
    <div class="status-banner status-empty" x-show="stats.total_chunks === 0">
      <div class="status-icon"><i data-feather="inbox"></i></div>
      <div class="status-text">
        <strong>Keine Chunks vorhanden</strong>
        <span>Importiere zuerst Dokumente und erstelle Chunks.</span>
      </div>
    </div>

    <!-- Stats Grid -->
    <div class="stats-grid" style="margin-top: 1rem;">
      <div class="stat-item">
        <span class="stat-value" x-text="stats.total_chunks.toLocaleString()">0</span>
        <span class="stat-label">Chunks gesamt</span>
      </div>
      <div class="stat-item stat-success">
        <span class="stat-value" x-text="embeddedChunks.toLocaleString()">0</span>
        <span class="stat-label">Mit Embedding</span>
      </div>
      <div class="stat-item" :class="pendingChunks > 0 ? 'stat-pending' : ''">
        <span class="stat-value" x-text="pendingChunks.toLocaleString()">0</span>
        <span class="stat-label">Ausstehend</span>
      </div>
    </div>

    <!-- Orphaned Warning -->
    <div class="orphan-warning" x-show="stats.orphaned_embeddings > 0">
      <span class="warning-icon"><i data-feather="alert-triangle"></i></span>
      <span x-text="stats.orphaned_embeddings + ' verwaiste Embeddings (geloeschte Chunks) - koennen spaeter bereinigt werden'"></span>
    </div>
  </div>

  <!-- Job Control Card -->
  <div class="card" x-show="pendingChunks > 0 || status !== 'idle'">
    <h2>Generierung</h2>

    <!-- Cost Estimate (before start) -->
    <div class="cost-estimate" x-show="status === 'idle' && pendingChunks > 0">
      <strong>Geschaetzte Kosten:</strong>
      $<span x-text="(pendingChunks * 200 * 0.02 / 1000000).toFixed(2)"></span>
      <span class="cost-detail">(<span x-text="pendingChunks.toLocaleString()"></span> Chunks × ~200 Tokens × $0.02/1M)</span>
    </div>

    <!-- Progress Section (during/after job) -->
    <div x-show="status !== 'idle'">
      <div class="progress-header">
        <span class="progress-status" :class="{
          'text-success': status === 'completed',
          'text-error': status === 'failed' || status === 'error',
          'text-warning': status === 'paused' || status === 'cancelled'
        }" x-text="statusText"></span>
        <span class="progress-percent" x-text="Math.round(progressPercent) + '%'"></span>
      </div>

      <div class="progress-bar">
        <div class="progress-fill" :class="{
          'progress-success': status === 'completed',
          'progress-error': status === 'failed',
          'progress-warning': status === 'paused'
        }" :style="'width: ' + progressPercent + '%'"></div>
      </div>

      <div class="progress-details">
        <span x-text="itemsProcessed.toLocaleString() + ' / ' + itemsTotal.toLocaleString() + ' Chunks'"></span>
        <span x-show="tokensUsed > 0" x-text="tokensUsed.toLocaleString() + ' Tokens'"></span>
        <span x-show="costUsd > 0" x-text="'$' + costUsd.toFixed(4)"></span>
      </div>

      <!-- Speed & ETA -->
      <div class="progress-speed" x-show="speed > 0 && status === 'running'">
        <span x-text="speed.toFixed(0) + ' Chunks/Sek'"></span>
        <span x-text="'~' + Math.ceil((itemsTotal - itemsProcessed) / speed / 60) + ' Min verbleibend'"></span>
      </div>
    </div>

    <!-- Completion Summary -->
    <div class="completion-summary" x-show="status === 'completed'">
      <div class="summary-icon"><i data-feather="check-circle"></i></div>
      <div class="summary-text">
        <strong>Erfolgreich abgeschlossen!</strong>
        <span x-text="itemsSucceeded.toLocaleString() + ' Chunks verarbeitet'"></span>
        <span x-show="itemsFailed > 0" class="text-error" x-text="itemsFailed + ' Fehler'"></span>
        <span x-text="'Kosten: $' + costUsd.toFixed(4)"></span>
      </div>
    </div>

    <!-- Error Display -->
    <div class="error-banner" x-show="errorMsg">
      <strong>Fehler:</strong> <span x-text="errorMsg"></span>
    </div>

    <!-- Action Buttons -->
    <div class="action-buttons">
      <!-- Start Button -->
      <button
        @click="startEmbed()"
        class="btn btn-primary"
        :disabled="status === 'running' || status === 'starting'"
        x-show="(status === 'idle' || status === 'completed' || status === 'error' || status === 'cancelled') && pendingChunks > 0">
        <span x-text="pendingChunks.toLocaleString() + ' Chunks embedden'"></span>
        <span class="btn-cost" x-text="'(~$' + (pendingChunks * 200 * 0.02 / 1000000).toFixed(2) + ')'"></span>
      </button>

      <!-- Pause Button -->
      <button
        @click="pauseEmbed()"
        class="btn btn-warning"
        x-show="status === 'running'">
        <i data-feather="pause"></i> Pausieren
      </button>

      <!-- Resume Button -->
      <button
        @click="resumeEmbed()"
        class="btn btn-primary"
        x-show="status === 'paused'">
        <i data-feather="play"></i> Fortsetzen
      </button>

      <!-- Cancel Button -->
      <button
        @click="cancelEmbed()"
        class="btn btn-danger"
        x-show="status === 'running' || status === 'paused'">
        <i data-feather="x-circle"></i> Abbrechen
      </button>

      <!-- Refresh Button (when all done) -->
      <button
        @click="refreshStats()"
        class="btn btn-secondary"
        x-show="status === 'idle' && pendingChunks === 0 && stats.total_chunks > 0">
        <i data-feather="refresh-cw"></i> Auf neue Chunks pruefen
      </button>
    </div>

    <!-- Action Hint -->
    <p class="action-hint" x-show="status === 'idle' && pendingChunks > 0">
      Klicke auf den Button um die Embedding-Generierung zu starten.
      Du kannst jederzeit pausieren und spaeter fortsetzen.
    </p>
    <p class="action-hint" x-show="status === 'paused'">
      Job pausiert. Klicke "Fortsetzen" um weiterzumachen, oder "Abbrechen" um zu beenden.
    </p>
    <p class="action-hint" x-show="status === 'completed' && pendingChunks === 0">
      Alle Chunks wurden verarbeitet. Die semantische Suche ist jetzt vollstaendig.
    </p>
  </div>

  <!-- Resume Banner (for interrupted jobs) -->
  {% if resumable_job %}
  <div class="card resume-card" x-show="!jobId || jobId !== '{{ resumable_job.id }}'">
    <h2>Unterbrochener Job gefunden</h2>
    <p>
      Ein vorheriger Job wurde unterbrochen und kann fortgesetzt werden.
    </p>
    <div class="resume-details">
      <span><strong>Status:</strong> {{ resumable_job.status.value }}</span>
      <span><strong>Fortschritt:</strong> {{ resumable_job.items_processed }} / {{ resumable_job.items_total or '?' }}</span>
      <span><strong>Kosten bisher:</strong> ${{ "%.4f"|format(resumable_job.cost_usd) }}</span>
    </div>
    <button @click="resumeJob('{{ resumable_job.id }}')" class="btn btn-primary">
      <i data-feather="play"></i> Job fortsetzen
    </button>
  </div>
  {% endif %}

  <!-- Live Log -->
  <div class="card" x-show="log.length > 0">
    <h2>Aktivitaets-Log</h2>
    <div class="log-container">
      <template x-for="(entry, index) in log" :key="index">
        <div class="log-entry" :class="'log-' + entry.type">
          <span class="log-time" x-text="entry.time"></span>
          <span x-text="entry.msg"></span>
        </div>
      </template>
    </div>
  </div>

  <!-- Recent Jobs -->
  {% if jobs %}
  <div class="card">
    <h2>Vorherige Jobs</h2>
    <div class="job-list">
      {% for job in jobs %}
      <div class="job-item">
        <div class="job-header">
          <span class="job-id">{{ job.id[:8] }}</span>
          <span class="job-status job-status-{{ job.status.value }}">{{ job.status.value }}</span>
        </div>
        <div class="job-details">
          <span>{{ job.items_succeeded }} Erfolg</span>
          {% if job.items_failed > 0 %}<span class="text-error">{{ job.items_failed }} Fehler</span>{% endif %}
          <span>${{ "%.4f"|format(job.cost_usd) }}</span>
          <span class="job-time">{{ job.last_activity.strftime('%d.%m. %H:%M') }}</span>
        </div>
        <div class="job-progress">
          <div class="progress-bar-small">
            <div class="progress-fill" style="width: {{ job.progress_percent }}%"></div>
          </div>
        </div>
      </div>
      {% endfor %}
    </div>
  </div>
  {% endif %}

</div>

<style>
/* Info Card */
.info-card {
  background: var(--info-bg);
  border-left: 4px solid var(--primary);
}
.info-card p {
  margin-bottom: 1rem;
  line-height: 1.6;
}

/* Pipeline Visualization */
.pipeline {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-wrap: wrap;
  margin-top: 1rem;
}
.pipeline-step {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  background: var(--bg-secondary);
  border-radius: 8px;
}
.pipeline-step.current {
  background: var(--info-bg);
  border: 1px solid var(--primary);
}
.step-icon {
  width: 24px;
  height: 24px;
  background: var(--bg-secondary);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  font-weight: bold;
}
.current .step-icon {
  background: var(--primary);
  color: white;
}
.step-text {
  display: flex;
  flex-direction: column;
  font-size: 0.85rem;
}
.step-text span {
  font-size: 0.75rem;
  opacity: 0.7;
}
.pipeline-arrow {
  color: var(--text-muted);
  font-size: 1.2rem;
}

/* Status Banners */
.status-banner {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border-radius: 8px;
  margin-bottom: 1rem;
}
.status-success {
  background: var(--success-bg);
  border: 1px solid var(--success);
}
.status-pending {
  background: var(--info-bg);
  border: 1px solid var(--primary);
}
.status-empty {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
}
.status-icon {
  display: flex;
  align-items: center;
  justify-content: center;
}
.status-icon svg {
  width: 1.5rem;
  height: 1.5rem;
}
.status-success .status-icon { color: var(--success); }
.status-pending .status-icon { color: var(--primary); }
.status-text {
  display: flex;
  flex-direction: column;
}
.status-text span {
  font-size: 0.9rem;
  opacity: 0.8;
}

/* Stats Grid */
.stats-grid {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}
.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  background: var(--bg-hover);
  border-radius: 8px;
  min-width: 100px;
}
.stat-value {
  font-size: 1.8rem;
  font-weight: bold;
}
.stat-label {
  font-size: 0.8rem;
  opacity: 0.7;
}
.stat-success .stat-value { color: var(--success); }
.stat-pending .stat-value { color: var(--primary); }

/* Orphan Warning */
.orphan-warning {
  margin-top: 1rem;
  padding: 0.5rem 0.75rem;
  background: var(--warning-bg);
  border-radius: 6px;
  font-size: 0.85rem;
  color: var(--warning);
}
.warning-icon {
  display: inline-flex;
  align-items: center;
  margin-right: 0.5rem;
}
.warning-icon svg {
  width: 1rem;
  height: 1rem;
}

/* Cost Estimate */
.cost-estimate {
  padding: 0.75rem;
  background: var(--bg-hover);
  border-radius: 6px;
  margin-bottom: 1rem;
}
.cost-detail {
  font-size: 0.85rem;
  opacity: 0.7;
  margin-left: 0.5rem;
}

/* Progress */
.progress-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.5rem;
}
.progress-status {
  font-weight: 500;
}
.progress-percent {
  font-size: 1.2rem;
  font-weight: 600;
}
.progress-bar {
  background: var(--bg-secondary);
  border-radius: 4px;
  height: 8px;
  overflow: hidden;
}
.progress-fill {
  background: var(--primary);
  height: 100%;
  transition: width 0.3s ease;
}
.progress-success { background: var(--success); }
.progress-error { background: var(--error); }
.progress-warning { background: var(--warning); }
.progress-details {
  display: flex;
  gap: 1.5rem;
  margin-top: 0.5rem;
  font-size: 0.9rem;
  opacity: 0.8;
}
.progress-speed {
  display: flex;
  gap: 1.5rem;
  margin-top: 0.25rem;
  font-size: 0.85rem;
  color: var(--primary);
}

/* Completion Summary */
.completion-summary {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: var(--success-bg);
  border-radius: 8px;
  margin-top: 1rem;
}
.summary-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--success);
}
.summary-icon svg {
  width: 1.5rem;
  height: 1.5rem;
}
.summary-text {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}
.summary-text span {
  font-size: 0.9rem;
}

/* Error Banner */
.error-banner {
  padding: 0.75rem;
  background: var(--error-bg);
  border-radius: 6px;
  color: var(--error);
  margin-top: 1rem;
}

/* Action Buttons */
.action-buttons {
  display: flex;
  gap: 0.75rem;
  margin-top: 1rem;
  flex-wrap: wrap;
}
.btn-primary {
  background: var(--primary);
  color: white;
}
.btn-primary:hover:not(:disabled) {
  background: var(--primary-hover);
}
.btn-warning {
  background: var(--warning);
  color: white;
}
.btn-danger {
  background: var(--error);
  color: white;
}
.btn-secondary {
  background: var(--bg-secondary);
  color: inherit;
}
.btn-cost {
  font-size: 0.85rem;
  opacity: 0.9;
  margin-left: 0.5rem;
}
.action-hint {
  margin-top: 0.75rem;
  font-size: 0.85rem;
  opacity: 0.7;
}

/* Resume Card */
.resume-card {
  background: var(--warning-bg);
  border-left: 4px solid var(--warning);
}
.resume-details {
  display: flex;
  gap: 1.5rem;
  margin: 1rem 0;
  font-size: 0.9rem;
}

/* Log */
.log-container {
  max-height: 200px;
  overflow-y: auto;
  font-family: monospace;
  font-size: 0.85rem;
  background: var(--bg-hover);
  padding: 0.5rem;
  border-radius: 8px;
}
.log-entry {
  padding: 0.25rem 0;
  border-bottom: 1px solid var(--border);
}
.log-time {
  opacity: 0.5;
  margin-right: 0.5rem;
}
.log-batch_complete { color: var(--success); }
.log-started, .log-completed { font-weight: bold; }
.log-completed { color: var(--success); }
.log-failed, .log-error { color: var(--error); }
.log-paused, .log-cancelled { color: var(--warning); }

/* Job List */
.job-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}
.job-item {
  padding: 0.75rem;
  background: var(--bg-hover);
  border-radius: 8px;
}
.job-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.5rem;
}
.job-id {
  font-family: monospace;
  font-weight: bold;
}
.job-status {
  font-size: 0.8rem;
  padding: 0.1rem 0.5rem;
  border-radius: 4px;
}
.job-status-completed { background: var(--success-bg); color: var(--success); }
.job-status-running { background: var(--info-bg); color: var(--primary); }
.job-status-paused { background: var(--warning-bg); color: var(--warning); }
.job-status-failed { background: var(--error-bg); color: var(--error); }
.job-status-cancelled { background: var(--bg-secondary); }
.job-status-pending { background: var(--bg-secondary); }
.job-details {
  display: flex;
  gap: 1rem;
  font-size: 0.85rem;
  opacity: 0.8;
  margin-bottom: 0.5rem;
}
.job-time {
  margin-left: auto;
}
.job-progress {
  margin-top: 0.25rem;
}
.progress-bar-small {
  background: var(--bg-secondary);
  border-radius: 2px;
  height: 4px;
  overflow: hidden;
}

/* Text colors */
.text-success { color: var(--success); }
.text-error { color: var(--error); }
.text-warning { color: var(--warning); }
</style>

<script>
function embedApp() {
  return {
    stats: {
      total_chunks: {{ stats.total_chunks }},
      embedded_chunks: {{ stats.embedded_chunks }},
      pending_chunks: {{ stats.pending_chunks }},
      orphaned_embeddings: {{ stats.orphaned_embeddings | default(0) }}
    },
    jobId: null,
    status: 'idle',
    itemsProcessed: 0,
    itemsSucceeded: 0,
    itemsFailed: 0,
    itemsTotal: {{ stats.pending_chunks }},
    progressPercent: 0,
    tokensUsed: 0,
    costUsd: 0,
    errorMsg: '',
    log: [],
    eventSource: null,
    startTime: null,
    speed: 0,

    get embeddedChunks() {
      return this.stats.embedded_chunks;
    },
    get pendingChunks() {
      return Math.max(0, this.stats.pending_chunks);
    },
    get statusText() {
      const texts = {
        'idle': 'Bereit',
        'starting': 'Wird gestartet...',
        'running': 'Laeuft...',
        'paused': 'Pausiert',
        'completed': 'Abgeschlossen',
        'cancelled': 'Abgebrochen',
        'failed': 'Fehlgeschlagen',
        'error': 'Fehler'
      };
      return texts[this.status] || this.status;
    },

    init() {
      {% if running_job %}
      this.jobId = '{{ running_job.id }}';
      this.status = 'running';
      this.itemsProcessed = {{ running_job.items_processed }};
      this.itemsSucceeded = {{ running_job.items_succeeded }};
      this.itemsFailed = {{ running_job.items_failed }};
      this.itemsTotal = {{ running_job.items_total or 0 }};
      this.progressPercent = {{ running_job.progress_percent }};
      this.tokensUsed = {{ running_job.tokens_used }};
      this.costUsd = {{ running_job.cost_usd }};
      this.startTime = Date.now();
      this.connectStream();
      {% endif %}
    },

    async refreshStats() {
      try {
        const res = await fetch('/api/embed/stats');
        if (res.ok) {
          this.stats = await res.json();
          this.itemsTotal = this.stats.pending_chunks;
        }
      } catch (e) {
        console.error('Stats refresh failed:', e);
      }
    },

    addLog(type, msg) {
      const now = new Date();
      const time = now.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      this.log.unshift({ type, msg, time });
      if (this.log.length > 50) {
        this.log = this.log.slice(0, 50);
      }
    },

    updateSpeed() {
      if (this.startTime && this.itemsProcessed > 0) {
        const elapsed = (Date.now() - this.startTime) / 1000;
        this.speed = this.itemsProcessed / elapsed;
      }
    },

    async startEmbed() {
      this.status = 'starting';
      this.errorMsg = '';
      this.log = [];
      this.itemsProcessed = 0;
      this.itemsSucceeded = 0;
      this.itemsFailed = 0;
      this.tokensUsed = 0;
      this.costUsd = 0;
      this.startTime = Date.now();
      this.speed = 0;

      try {
        const resp = await fetch('/api/embed/start', { method: 'POST' });
        const data = await resp.json();

        if (data.error) {
          this.errorMsg = data.error;
          this.status = 'error';
          return;
        }

        this.jobId = data.job_id;
        this.itemsTotal = data.items_total;
        this.addLog('started', 'Embedding-Job gestartet');
        this.connectStream();

      } catch (e) {
        this.status = 'error';
        this.errorMsg = 'Verbindungsfehler: ' + e.message;
      }
    },

    connectStream() {
      if (this.eventSource) {
        this.eventSource.close();
      }

      const url = '/api/embed/' + this.jobId + '/stream';
      this.eventSource = new EventSource(url);
      this.status = 'running';

      this.eventSource.addEventListener('started', (e) => {
        this.addLog('started', 'Verarbeitung gestartet');
      });

      this.eventSource.addEventListener('batch_complete', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.updateSpeed();
        this.addLog('batch_complete', data.batch_size + ' Chunks (' + data.batch_tokens.toLocaleString() + ' Tokens)');
        // Update live stats
        this.stats.embedded_chunks += data.batch_size;
        this.stats.pending_chunks -= data.batch_size;
      });

      this.eventSource.addEventListener('paused', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.status = 'paused';
        this.addLog('paused', 'Job pausiert');
        this.eventSource.close();
      });

      this.eventSource.addEventListener('completed', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.status = 'completed';
        this.progressPercent = 100;
        this.addLog('completed', 'Fertig: ' + this.itemsSucceeded.toLocaleString() + ' Chunks, $' + this.costUsd.toFixed(4));
        this.eventSource.close();
        this.refreshStats();
      });

      this.eventSource.addEventListener('failed', (e) => {
        const data = JSON.parse(e.data);
        this.status = 'failed';
        this.errorMsg = data.error || 'Unbekannter Fehler';
        this.addLog('failed', 'Fehler: ' + this.errorMsg);
        this.eventSource.close();
      });

      this.eventSource.addEventListener('cancelled', (e) => {
        this.status = 'cancelled';
        this.addLog('cancelled', 'Job abgebrochen');
        this.eventSource.close();
      });

      this.eventSource.onerror = () => {
        if (this.status === 'running') {
          this.status = 'error';
          this.errorMsg = 'Verbindung verloren';
          this.addLog('error', 'Verbindung zum Server verloren');
        }
        this.eventSource.close();
      };
    },

    updateFromData(data) {
      this.itemsProcessed = data.items_processed || this.itemsProcessed;
      this.itemsSucceeded = data.items_succeeded || this.itemsSucceeded;
      this.itemsFailed = data.items_failed || this.itemsFailed;
      this.progressPercent = data.progress_percent || this.progressPercent;
      this.tokensUsed = data.tokens_used || this.tokensUsed;
      this.costUsd = data.cost_usd || this.costUsd;
    },

    async pauseEmbed() {
      if (!this.jobId) return;
      try {
        await fetch('/api/embed/' + this.jobId + '/pause', { method: 'POST' });
        this.addLog('paused', 'Pause angefordert...');
      } catch (e) {
        this.errorMsg = 'Fehler: ' + e.message;
      }
    },

    async resumeEmbed() {
      if (!this.jobId) return;
      this.startTime = Date.now() - (this.itemsProcessed / (this.speed || 1) * 1000);
      try {
        await fetch('/api/embed/' + this.jobId + '/resume', { method: 'POST' });
        this.addLog('started', 'Wird fortgesetzt...');
        this.connectStream();
      } catch (e) {
        this.errorMsg = 'Fehler: ' + e.message;
      }
    },

    async resumeJob(previousJobId) {
      this.jobId = previousJobId;
      this.status = 'starting';
      this.errorMsg = '';
      this.log = [];
      this.startTime = Date.now();

      try {
        const statusResp = await fetch('/api/embed/' + previousJobId + '/status');
        const statusData = await statusResp.json();
        if (statusData.items_processed) {
          this.itemsProcessed = statusData.items_processed;
          this.itemsSucceeded = statusData.items_succeeded;
          this.itemsFailed = statusData.items_failed;
          this.itemsTotal = statusData.items_total;
          this.tokensUsed = statusData.tokens_used;
          this.costUsd = statusData.cost_usd;
        }

        await fetch('/api/embed/' + previousJobId + '/resume', { method: 'POST' });
        this.addLog('started', 'Job wird fortgesetzt...');
        this.connectStream();
      } catch (e) {
        this.errorMsg = 'Fehler: ' + e.message;
        this.status = 'error';
      }
    },

    async cancelEmbed() {
      if (!this.jobId) return;
      try {
        await fetch('/api/embed/' + this.jobId + '/cancel', { method: 'POST' });
        this.status = 'cancelled';
        this.addLog('cancelled', 'Job abgebrochen');
        if (this.eventSource) {
          this.eventSource.close();
        }
      } catch (e) {
        this.errorMsg = 'Fehler: ' + e.message;
      }
    }
  };
}
</script>

{% endblock %}
