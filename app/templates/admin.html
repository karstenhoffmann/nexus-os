{% extends "base.html" %}
{% block content %}

<h1>Admin</h1>
<p class="text-base-content/60 mb-4">System-Konfiguration und Hintergrund-Jobs verwalten</p>

<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
  <div class="card bg-base-100 shadow-md">
    <div class="card-body">
      <h2 class="card-title">Umgebung</h2>
      <p class="text-sm text-base-content/60">Aktuelle Systemkonfiguration aus Umgebungsvariablen (nur lesbar)</p>
      <div class="divider my-2"></div>
      <div class="flex justify-between py-1"><span>Modus</span><span class="font-medium">{{ settings.app_env }}</span></div>
      <div class="flex justify-between py-1"><span>Datenbank</span><span class="font-medium">{{ settings.db_path }}</span></div>
      <div class="flex justify-between py-1"><span>LLM-Anbieter</span><span class="font-medium">{{ settings.llm_provider }}</span></div>
    </div>
  </div>

  <div class="card bg-base-100 shadow-md">
    <div class="card-body">
      <h2 class="card-title">Datenbestand</h2>
      <p class="text-sm text-base-content/60">Anzahl der gespeicherten Inhalte in der Datenbank</p>
      <div class="divider my-2"></div>
      <div class="flex justify-between py-1"><span>Dokumente</span><span class="font-medium">{{ stats.documents }}</span></div>
      <div class="flex justify-between py-1"><span>Highlights</span><span class="font-medium">{{ stats.highlights }}</span></div>
      <div class="flex justify-between py-1"><span>Entwuerfe</span><span class="font-medium">{{ stats.drafts }}</span></div>
    </div>
  </div>
</div>

<!-- Embedding Job Card -->
<div class="card bg-base-100 shadow-md mt-6" x-data="embeddingJob()" x-init="init()">
  <div class="card-body">
    <h2 class="card-title">Semantische Suche</h2>
    <p class="text-sm text-base-content/60">
      Embeddings wandeln Text in Vektoren um, damit die Suche nach Bedeutung statt nur nach Worten funktioniert.
      Jedes Dokument wird in Chunks (~800 Zeichen) aufgeteilt, die einzeln durchsuchbar sind.
    </p>

    <!-- Status Overview -->
    <div class="my-4">
      <div class="flex justify-between items-center mb-2">
        <span class="text-lg font-medium" x-text="statusText"></span>
        <span class="text-2xl font-semibold" x-text="progress + '%'"></span>
      </div>

      <!-- Progress Bar -->
      <progress class="progress progress-primary w-full" :value="progress" max="100"></progress>

      <div class="flex justify-between mt-2 text-sm text-base-content/60">
        <span x-text="totalEmbedded.toLocaleString() + ' von ' + stats.total_chunks.toLocaleString() + ' Chunks'"></span>
        <span x-show="pending > 0" x-text="pending.toLocaleString() + ' ausstehend'"></span>
      </div>
    </div>

    <!-- Provider Info -->
    <template x-if="stats.by_provider && stats.by_provider.length > 0">
      <div class="bg-base-200 p-3 rounded-lg mb-4">
        <div class="text-xs text-base-content/60 mb-1">Aktiver Anbieter</div>
        <template x-for="p in stats.by_provider" :key="p.provider + p.model">
          <div class="font-medium" x-text="p.provider + ' / ' + p.model"></div>
        </template>
      </div>
    </template>

    <!-- Job Controls -->
    <div x-show="pending > 0">
      <!-- Not Running State -->
      <div x-show="!jobRunning">
        <button class="btn btn-primary" @click="startJob()">
          Embeddings generieren starten
        </button>
        <p class="text-sm text-base-content/60 mt-2">
          Verarbeitet 1000 Chunks pro Welle (~15-20 Sek.). Fortschritt nach jeder Welle sichtbar.
        </p>
      </div>

      <!-- Running State -->
      <div x-show="jobRunning">
        <div class="flex items-center gap-4">
          <span class="loading loading-spinner loading-md"></span>
          <div>
            <div class="font-medium" x-text="jobStatus"></div>
            <div class="text-sm text-base-content/60" x-text="'Welle ' + currentBatch + ' von ~' + Math.ceil(pending / 1000)"></div>
          </div>
        </div>
        <button class="btn btn-outline mt-4" @click="stopJob()">
          Nach dieser Welle stoppen
        </button>
      </div>

      <!-- Result Message -->
      <div x-show="lastResult" class="alert alert-success mt-4">
        <span x-text="lastResult"></span>
      </div>

      <!-- Error Message -->
      <div x-show="error" class="alert alert-error mt-4">
        <span x-text="error"></span>
      </div>
    </div>

    <!-- All Done State -->
    <div x-show="pending === 0 && stats.total_chunks > 0" class="alert alert-success">
      <span class="text-xl">âœ“</span>
      <span>Alle Chunks haben Embeddings - Semantische Suche ist bereit!</span>
    </div>
  </div>
</div>

<!-- Design Section -->
<div class="card bg-base-100 shadow-md mt-6" x-data="themeEditor()" x-init="loadTheme()">
  <div class="card-body">
    <h2 class="card-title">Design</h2>
    <p class="text-sm text-base-content/60">Passe das Erscheinungsbild der App an. Dark Mode wird automatisch vom System uebernommen.</p>

    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
      <!-- Primaerfarbe -->
      <div class="form-control">
        <label class="label"><span class="label-text">Primaerfarbe</span></label>
        <div class="flex items-center gap-2">
          <input type="color" x-model="primary" @change="saveTheme()" class="w-10 h-10 rounded cursor-pointer">
          <span x-text="primary" class="font-mono text-sm"></span>
        </div>
      </div>

      <!-- Spacing -->
      <div class="form-control">
        <label class="label"><span class="label-text">Abstaende</span></label>
        <select x-model="spacing" @change="saveTheme()" class="select select-bordered select-sm">
          <option value="compact">Kompakt</option>
          <option value="normal">Normal</option>
          <option value="spacious">Grosszuegig</option>
        </select>
      </div>

      <!-- Border Radius -->
      <div class="form-control">
        <label class="label"><span class="label-text">Ecken</span></label>
        <select x-model="radius" @change="saveTheme()" class="select select-bordered select-sm">
          <option value="sharp">Eckig</option>
          <option value="rounded">Gerundet</option>
          <option value="pill">Stark gerundet</option>
        </select>
      </div>

      <!-- Font Size -->
      <div class="form-control">
        <label class="label"><span class="label-text">Schriftgroesse</span></label>
        <select x-model="fontSize" @change="saveTheme()" class="select select-bordered select-sm">
          <option value="small">Klein</option>
          <option value="medium">Normal</option>
          <option value="large">Gross</option>
        </select>
      </div>
    </div>

    <div class="flex items-center gap-4 mt-4">
      <button class="btn btn-outline btn-sm" @click="resetTheme()">Zuruecksetzen</button>
      <span x-show="saved" x-transition class="text-success text-sm">Gespeichert</span>
    </div>
  </div>
</div>

<!-- Tools Section -->
<h2 class="mt-8 mb-4">Werkzeuge</h2>
<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
  <a href="/admin/compare" class="card bg-base-100 shadow-md hover:shadow-lg transition-shadow">
    <div class="card-body">
      <h3 class="card-title text-base">Modell-Vergleich</h3>
      <p class="text-sm text-base-content/60">Vergleiche Suchergebnisse von verschiedenen Embedding-Modellen (OpenAI vs Ollama) nebeneinander.</p>
    </div>
  </a>

  <a href="/admin/fetch" class="card bg-base-100 shadow-md hover:shadow-lg transition-shadow">
    <div class="card-body">
      <h3 class="card-title text-base">Fulltext Fetching</h3>
      <p class="text-sm text-base-content/60">Hole Artikel-Volltexte von Original-URLs. Notwendig wenn nur Titel/Summary vorhanden sind.</p>
    </div>
  </a>

  <a href="/admin/prompts" class="card bg-base-100 shadow-md hover:shadow-lg transition-shadow">
    <div class="card-body">
      <h3 class="card-title text-base">Prompt-Vorlagen</h3>
      <p class="text-sm text-base-content/60">LLM-Prompts fuer Digest-Generierung anpassen. Temperature und Max-Tokens konfigurieren.</p>
    </div>
  </a>
</div>

<!-- Styles migrated to DaisyUI classes -->

<script>
function embeddingJob() {
  return {
    stats: { total_documents: 0, total_chunks: 0, by_provider: [], legacy_embeddings: 0 },
    jobRunning: false,
    jobStatus: '',
    currentBatch: 0,
    lastResult: null,
    error: null,
    stopRequested: false,

    get totalEmbedded() {
      if (!this.stats.by_provider) return 0;
      return this.stats.by_provider.reduce((sum, p) => sum + (p.chunk_embeddings || 0), 0);
    },
    get pending() {
      return Math.max(0, this.stats.total_chunks - this.totalEmbedded);
    },
    get progress() {
      if (this.stats.total_chunks === 0) return 0;
      return Math.round(this.totalEmbedded / this.stats.total_chunks * 100);
    },
    get statusText() {
      if (this.pending === 0) return 'Vollstaendig';
      if (this.jobRunning) return 'Generiere...';
      return 'Bereit';
    },

    init() {
      this.refreshStats();
      // Poll every 2 seconds for live updates
      setInterval(() => this.refreshStats(), 2000);
    },

    async refreshStats() {
      try {
        const res = await fetch('/api/embeddings/stats');
        if (res.ok) {
          this.stats = await res.json();
        }
      } catch (e) {
        // Ignore fetch errors during job
      }
    },

    async startJob() {
      this.jobRunning = true;
      this.error = null;
      this.lastResult = null;
      this.stopRequested = false;
      this.currentBatch = 0;

      // Process 1000 chunks per wave with 2 concurrent API calls of 500 chunks each
      // This balances speed with responsiveness (each wave ~15-20 seconds)
      const CHUNKS_PER_CALL = 1000;
      let totalProcessed = 0;
      let totalCost = 0;
      let totalDuration = 0;

      while (this.pending > 0 && !this.stopRequested) {
        this.currentBatch++;
        this.jobStatus = `Welle ${this.currentBatch}: ${Math.min(CHUNKS_PER_CALL, this.pending).toLocaleString()} Chunks...`;

        try {
          const startTime = Date.now();
          const res = await fetch(`/api/embeddings/generate-fast?limit=${CHUNKS_PER_CALL}&batch_size=500&max_concurrent=2`, {
            method: 'POST'
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          totalProcessed += data.processed || 0;
          totalCost += data.cost_usd || 0;
          totalDuration += data.duration_seconds || 0;

          // Refresh stats to show progress
          await this.refreshStats();

          // Update status with speed info
          if (data.chunks_per_second) {
            this.jobStatus = `${data.chunks_per_second} Chunks/Sek`;
          }

          // Stop if nothing was processed (error or done)
          if (data.processed === 0) {
            if (data.error) {
              this.error = data.error;
            }
            break;
          }

          // Small pause between waves
          await new Promise(r => setTimeout(r, 200));
        } catch (e) {
          this.error = `Fehler bei Welle ${this.currentBatch}: ${e.message}`;
          break;
        }
      }

      this.jobRunning = false;
      if (!this.error && totalProcessed > 0) {
        const avgSpeed = totalDuration > 0 ? Math.round(totalProcessed / totalDuration) : 0;
        this.lastResult = `${totalProcessed.toLocaleString()} Chunks in ${totalDuration.toFixed(1)}s (${avgSpeed} Chunks/Sek), Kosten: $${totalCost.toFixed(4)}`;
      } else if (this.stopRequested) {
        this.lastResult = `Abgebrochen nach ${totalProcessed.toLocaleString()} Chunks`;
      }
    },

    stopJob() {
      this.stopRequested = true;
      this.jobStatus = 'Wird abgebrochen...';
    }
  };
}

function themeEditor() {
  return {
    primary: '#3b82f6',
    spacing: 'normal',
    radius: 'rounded',
    fontSize: 'medium',
    saved: false,

    async loadTheme() {
      try {
        const res = await fetch('/api/admin/theme');
        const theme = await res.json();
        this.primary = theme.primary || '#3b82f6';
        this.spacing = theme.spacing || 'normal';
        this.radius = theme.radius || 'rounded';
        this.fontSize = theme.fontSize || 'medium';
      } catch (e) {
        // Fallback bleibt
      }
    },

    async saveTheme() {
      try {
        const params = new URLSearchParams({
          primary: this.primary,
          spacing: this.spacing,
          radius: this.radius,
          fontSize: this.fontSize
        });
        await fetch('/api/admin/theme?' + params.toString(), { method: 'POST' });

        // Sofort anwenden
        window.applyTheme({
          primary: this.primary,
          spacing: this.spacing,
          radius: this.radius,
          fontSize: this.fontSize
        });

        this.saved = true;
        setTimeout(() => this.saved = false, 2000);
      } catch (e) {
        console.error('Theme speichern fehlgeschlagen:', e);
      }
    },

    async resetTheme() {
      this.primary = '#3b82f6';
      this.spacing = 'normal';
      this.radius = 'rounded';
      this.fontSize = 'medium';
      await this.saveTheme();
    }
  };
}
</script>
{% endblock %}
