{% extends "base.html" %}
{% from "macros/icons.html" import icon %}
{% block content %}

<div x-data="syncApp()" x-init="init()">

  <!-- Hero: Title + Primary Action -->
  <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-6">
    <div>
      <h1 class="text-2xl font-bold">Sync Pipeline</h1>
      <p class="text-base-content/60 text-sm mt-1">Readwise importieren, Chunks erstellen, Embeddings generieren</p>
    </div>

    <!-- Primary Action (idle state) -->
    <div x-show="status === 'idle'">
      <button type="button" class="btn btn-primary gap-2" @click="startSync" :disabled="!token">
        {{ icon("play") }} Sync starten
      </button>
    </div>

    <!-- Running Controls -->
    <div class="flex gap-2" x-show="status === 'running'">
      <button type="button" class="btn btn-warning btn-sm gap-1" @click="pauseSync">
        {{ icon("pause") }} Pause
      </button>
      <button type="button" class="btn btn-error btn-sm gap-1" @click="cancelSync">
        {{ icon("x") }} Stop
      </button>
    </div>

    <!-- Paused Controls -->
    <div class="flex gap-2" x-show="status === 'paused'">
      <button type="button" class="btn btn-primary btn-sm gap-1" @click="resumeSync">
        {{ icon("play") }} Fortsetzen
      </button>
      <button type="button" class="btn btn-error btn-sm gap-1" @click="cancelSync">
        {{ icon("x") }} Stop
      </button>
    </div>

    <!-- Completed/Failed: Reset -->
    <div x-show="status === 'completed' || status === 'cancelled' || status === 'failed'">
      <button type="button" class="btn btn-outline btn-sm gap-1" @click="resetSync">
        {{ icon("refresh-cw") }} Neue Sync
      </button>
    </div>
  </div>

  <!-- Quick Stats Bar -->
  <div class="stats stats-vertical sm:stats-horizontal shadow bg-base-100 w-full mb-6">
    <div class="stat">
      <div class="stat-title text-xs">Dokumente</div>
      <div class="stat-value text-xl" x-text="stats.docs_total.toLocaleString()">{{ stats.docs_total }}</div>
      <div class="stat-desc flex items-center gap-1.5">
        <span class="w-1.5 h-1.5 rounded-full" :class="stats.docs_with_fulltext === stats.docs_total ? 'bg-success' : 'bg-warning'"></span>
        <span x-text="stats.docs_with_fulltext.toLocaleString() + ' mit Inhalt'"></span>
      </div>
    </div>
    <div class="stat">
      <div class="stat-title text-xs">Chunks</div>
      <div class="stat-value text-xl" x-text="stats.chunks_total.toLocaleString()">{{ stats.chunks_total }}</div>
      <div class="stat-desc flex items-center gap-1.5">
        <span class="w-1.5 h-1.5 rounded-full" :class="stats.docs_without_chunks === 0 ? 'bg-success' : 'bg-warning'"></span>
        <span x-text="stats.docs_without_chunks === 0 ? 'komplett' : stats.docs_without_chunks + ' Dok. ausstehend'"></span>
      </div>
    </div>
    <div class="stat">
      <div class="stat-title text-xs">Embeddings</div>
      <div class="stat-value text-xl" x-text="(stats.chunks_total - stats.chunks_without_embeddings).toLocaleString()">{{ stats.chunks_total - stats.chunks_without_embeddings }}</div>
      <div class="stat-desc flex items-center gap-1.5">
        <span class="w-1.5 h-1.5 rounded-full" :class="stats.chunks_without_embeddings === 0 ? 'bg-success' : 'bg-warning'"></span>
        <span x-text="stats.chunks_without_embeddings === 0 ? 'komplett' : stats.chunks_without_embeddings.toLocaleString() + ' ausstehend'"></span>
      </div>
    </div>
  </div>

  <!-- Pipeline Steps (DaisyUI) -->
  <div class="card bg-base-100 shadow-md mb-6" x-show="status !== 'idle' || phase !== 'idle'">
    <div class="card-body">
      <ul class="steps steps-vertical lg:steps-horizontal w-full">
        <li class="step" :class="{ 'step-primary': phase === 'import', 'step-success': phaseIndex > 1 }" data-content="1">
          <div class="text-left lg:text-center">
            <div class="font-medium text-sm">Import</div>
            <div class="text-xs text-base-content/60" x-text="docsImported > 0 ? docsImported.toLocaleString() + ' Dokumente' : ''"></div>
          </div>
        </li>
        <li class="step" :class="{ 'step-primary': phase === 'chunk', 'step-success': phaseIndex > 2 }" data-content="2">
          <div class="text-left lg:text-center">
            <div class="font-medium text-sm">Chunks</div>
            <div class="text-xs text-base-content/60" x-text="chunksCreated > 0 ? chunksCreated.toLocaleString() + ' erstellt' : ''"></div>
          </div>
        </li>
        <li class="step" :class="{ 'step-primary': phase === 'embed', 'step-success': phaseIndex > 3 }" data-content="3">
          <div class="text-left lg:text-center">
            <div class="font-medium text-sm">Embeddings</div>
            <div class="text-xs text-base-content/60" x-text="chunksEmbedded > 0 ? chunksEmbedded.toLocaleString() + ' / ' + chunksTotal.toLocaleString() : ''"></div>
          </div>
        </li>
        <li class="step" :class="{ 'step-primary': phase === 'index', 'step-success': phase === 'done' }" data-content="4">
          <div class="text-left lg:text-center">
            <div class="font-medium text-sm">Index</div>
            <div class="text-xs text-base-content/60" x-text="phase === 'done' ? 'Fertig' : ''"></div>
          </div>
        </li>
      </ul>

      <!-- Progress Detail (running phases) -->
      <div class="mt-4" x-show="status === 'running' && progressData">
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-2 text-sm">
            <span class="loading loading-spinner loading-sm text-primary"></span>
            <span x-text="currentActivity || progressData?.detail"></span>
          </div>
          <span class="text-sm font-medium" x-show="progressData?.percent !== null" x-text="progressData?.percent + '%'"></span>
        </div>
        <progress class="progress progress-primary w-full" :value="progressData?.percent ?? 0" :max="progressData?.percent !== null ? 100 : undefined"></progress>

        <!-- Cost info for embed phase -->
        <div class="flex gap-4 mt-2 text-xs text-base-content/50" x-show="phase === 'embed' && (tokensUsed > 0 || costUsd > 0)">
          <span x-show="tokensUsed > 0" x-text="tokensUsed.toLocaleString() + ' Tokens'"></span>
          <span x-show="costUsd > 0" x-text="'$' + costUsd.toFixed(4)"></span>
        </div>
      </div>
    </div>
  </div>

  <!-- Completion Alert -->
  <div class="alert alert-success mb-6" x-show="status === 'completed'" x-transition>
    <div class="flex items-center gap-3">
      {{ icon("check-circle") }}
      <div>
        <div class="font-semibold">Sync abgeschlossen!</div>
        <div class="text-sm flex flex-wrap gap-x-3 gap-y-1 mt-1">
          <span x-show="docsImported > 0"><strong x-text="docsImported"></strong> importiert</span>
          <span x-show="docsMerged > 0"><strong x-text="docsMerged"></strong> aktualisiert</span>
          <span x-show="chunksCreated > 0"><strong x-text="chunksCreated"></strong> Chunks</span>
          <span x-show="chunksEmbedded > 0"><strong x-text="chunksEmbedded"></strong> Embeddings</span>
          <span x-show="costUsd > 0">Kosten: <strong x-text="'$' + costUsd.toFixed(4)"></strong></span>
        </div>
      </div>
    </div>
  </div>

  <!-- Error Alert -->
  <div class="alert alert-error mb-6" x-show="error" x-transition>
    <div class="flex items-center gap-2">
      {{ icon("alert-circle") }}
      <span x-text="error"></span>
    </div>
  </div>

  <!-- Options (idle state only) -->
  <div class="card bg-base-100 shadow-md mb-6" x-show="status === 'idle'">
    <div class="card-body py-4">
      <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <label class="label cursor-pointer justify-start gap-3">
          <input type="checkbox" class="checkbox checkbox-sm checkbox-primary" x-model="skipImport">
          <span class="label-text">Import ueberspringen (nur Chunks + Embeddings)</span>
        </label>

        <!-- Cost Estimate -->
        <div class="flex items-center gap-2 text-sm text-base-content/60" x-show="stats.chunks_without_embeddings > 0">
          {{ icon("info") }}
          <span>
            Geschaetzte Kosten: <strong x-text="'$' + (stats.chunks_without_embeddings * 200 * 0.02 / 1000000).toFixed(4)"></strong>
            (<span x-text="stats.chunks_without_embeddings.toLocaleString()"></span> Chunks)
          </span>
        </div>
      </div>
    </div>
  </div>

  <!-- Log (collapsible) -->
  <div class="collapse collapse-arrow bg-base-100 shadow-md" x-show="log.length > 0">
    <input type="checkbox" />
    <div class="collapse-title font-medium flex items-center gap-2">
      {{ icon("terminal") }} Verlauf
      <span class="badge badge-ghost badge-sm" x-text="log.length + ' Eintraege'"></span>
    </div>
    <div class="collapse-content">
      <div class="max-h-48 overflow-y-auto font-mono text-xs bg-base-200 p-3 rounded-lg">
        <template x-for="entry in log.slice(-20).reverse()" :key="entry.time">
          <div class="py-1 border-b border-base-300 last:border-0" :class="{
            'text-success': entry.level === 'success',
            'text-warning': entry.level === 'warning',
            'text-error': entry.level === 'error'
          }">
            <span class="opacity-50 mr-2" x-text="entry.time"></span>
            <span x-text="entry.message"></span>
          </div>
        </template>
      </div>
    </div>
  </div>

  <!-- Help (collapsed at bottom) -->
  <div class="collapse collapse-arrow bg-base-100 shadow-md mt-4">
    <input type="checkbox" />
    <div class="collapse-title text-sm font-medium flex items-center gap-2">
      {{ icon("help-circle") }} Was passiert beim Sync?
    </div>
    <div class="collapse-content text-sm text-base-content/70">
      <p>Holt neue Inhalte von Readwise und verarbeitet sie automatisch:</p>
      <ul class="list-disc list-inside mt-2 space-y-1">
        <li><strong>Import:</strong> Neue Dokumente von Readwise holen</li>
        <li><strong>Chunks:</strong> Lange Texte in Abschnitte teilen</li>
        <li><strong>Embeddings:</strong> Semantische Vektoren generieren (kostenpflichtig)</li>
        <li><strong>Index:</strong> Volltextsuche aktualisieren</li>
      </ul>
      <p class="mt-2">Bestehende Dokumente bleiben unveraendert.</p>
    </div>
  </div>

</div>

<script>
const INITIAL_STATS = {{ stats | tojson | safe }};
const TOKEN = '{{ token }}';

function syncApp() {
  return {
    // State
    status: 'idle',
    phase: 'idle',
    jobId: null,
    eventSource: null,
    skipImport: false,

    // Counters
    docsImported: 0,
    docsMerged: 0,
    chunksCreated: 0,
    docsProcessed: 0,
    docsToChunk: 0,
    chunksEmbedded: 0,
    chunksTotal: 0,
    tokensUsed: 0,
    costUsd: 0,
    itemsTotal: 0,

    // Stats from server
    stats: INITIAL_STATS,

    // UI
    currentActivity: '',
    error: null,
    log: [],

    // Heartbeat monitoring
    lastHeartbeat: null,
    heartbeatTimer: null,

    // Computed
    get phaseIndex() {
      const phases = ['idle', 'import', 'chunk', 'embed', 'index', 'done'];
      return phases.indexOf(this.phase);
    },

    get phaseLabel() {
      const labels = {
        'idle': 'Bereit',
        'import': 'Import von Readwise...',
        'chunk': 'Erstelle Chunks...',
        'embed': 'Generiere Embeddings...',
        'index': 'Aktualisiere Index...',
        'done': 'Fertig'
      };
      return labels[this.phase] || this.phase;
    },

    get progressData() {
      if (this.phase === 'import') {
        const rawPercent = this.itemsTotal > 0
          ? Math.round((this.docsImported / this.itemsTotal) * 100)
          : null;
        const percent = rawPercent !== null ? Math.min(rawPercent, 100) : null;
        return {
          percent,
          label: 'Importiere von Readwise...',
          detail: this.itemsTotal > 0
            ? `${this.docsImported.toLocaleString()} / ${this.itemsTotal.toLocaleString()} Dokumente`
            : `${this.docsImported.toLocaleString()} Dokumente importiert`
        };
      }
      if (this.phase === 'chunk') {
        const percent = this.docsToChunk > 0
          ? Math.round((this.docsProcessed / this.docsToChunk) * 100)
          : null;
        return {
          percent,
          label: 'Erstelle Chunks...',
          detail: this.docsToChunk > 0
            ? `${this.docsProcessed} / ${this.docsToChunk} Dokumente (${this.chunksCreated.toLocaleString()} Chunks)`
            : `${this.chunksCreated.toLocaleString()} Chunks erstellt`
        };
      }
      if (this.phase === 'embed') {
        const percent = this.chunksTotal > 0
          ? Math.round((this.chunksEmbedded / this.chunksTotal) * 100)
          : 0;
        return {
          percent,
          label: 'Generiere Embeddings...',
          detail: `${this.chunksEmbedded.toLocaleString()} / ${this.chunksTotal.toLocaleString()} Chunks`
        };
      }
      if (this.phase === 'index') {
        return {
          percent: null,
          label: 'Aktualisiere Index...',
          detail: 'FTS-Index wird neu aufgebaut'
        };
      }
      return null;
    },

    get token() {
      return TOKEN;
    },

    // Lifecycle
    init() {},

    // Actions
    async startSync() {
      this.resetState();
      this.status = 'running';

      try {
        const formData = new FormData();
        formData.append('token', TOKEN);
        formData.append('skip_import', this.skipImport);

        const res = await fetch('/api/sync/start', {
          method: 'POST',
          body: formData
        });

        const data = await res.json();
        if (data.error) {
          this.error = data.error;
          this.status = 'failed';
          return;
        }

        this.jobId = data.job_id;
        this.connectStream();
      } catch (e) {
        this.error = 'Fehler beim Starten: ' + e.message;
        this.status = 'failed';
      }
    },

    connectStream() {
      if (this.eventSource) {
        this.eventSource.close();
      }

      this.eventSource = new EventSource(`/api/sync/${this.jobId}/stream`);

      this.eventSource.addEventListener('phase_start', (e) => {
        const data = JSON.parse(e.data);
        this.phase = data.phase;
        this.currentActivity = data.message || '';
        this.lastHeartbeat = Date.now();
        this.addLog('info', data.message || `Phase ${data.phase} gestartet`);
      });

      this.eventSource.addEventListener('phase_progress', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.lastHeartbeat = Date.now();
        if (data.message) {
          this.currentActivity = data.message;
          this.addLog('info', data.message);
        } else {
          this.currentActivity = '';
        }
      });

      this.eventSource.addEventListener('phase_complete', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.lastHeartbeat = Date.now();
        this.addLog('success', `Phase ${data.phase} abgeschlossen`);
      });

      this.eventSource.addEventListener('pipeline_complete', (e) => {
        const data = JSON.parse(e.data);
        this.updateFromData(data);
        this.status = 'completed';
        this.phase = 'done';
        this.currentActivity = '';
        this.addLog('success', 'Sync erfolgreich abgeschlossen!');
        this.eventSource.close();
        this.stopHeartbeatMonitor();
        this.refreshStats();
      });

      this.eventSource.addEventListener('pipeline_paused', (e) => {
        this.status = 'paused';
        this.addLog('warning', 'Pipeline pausiert');
        this.eventSource.close();
        this.stopHeartbeatMonitor();
      });

      this.eventSource.addEventListener('pipeline_cancelled', (e) => {
        this.status = 'cancelled';
        this.addLog('warning', 'Pipeline abgebrochen');
        this.eventSource.close();
        this.stopHeartbeatMonitor();
      });

      this.eventSource.addEventListener('pipeline_failed', (e) => {
        const data = JSON.parse(e.data);
        this.status = 'failed';
        this.error = data.error;
        this.addLog('error', 'Fehler: ' + data.error);
        this.eventSource.close();
        this.stopHeartbeatMonitor();
      });

      this.eventSource.addEventListener('heartbeat', (e) => {
        const data = JSON.parse(e.data);
        this.lastHeartbeat = Date.now();
        if (data.message) {
          this.currentActivity = data.message;
        }
      });

      this.eventSource.onerror = (e) => {
        console.error('SSE error:', e);
        if (this.status === 'running') {
          this.addLog('error', 'Verbindung unterbrochen');
        }
        this.stopHeartbeatMonitor();
      };

      this.startHeartbeatMonitor();
    },

    startHeartbeatMonitor() {
      this.lastHeartbeat = Date.now();
      this.heartbeatTimer = setInterval(() => {
        if (this.status === 'running' && this.lastHeartbeat) {
          const elapsed = Date.now() - this.lastHeartbeat;
          if (elapsed > 10000) {
            this.addLog('warning', 'Keine Antwort vom Server seit 10s');
            this.lastHeartbeat = Date.now();
          }
        }
      }, 5000);
    },

    stopHeartbeatMonitor() {
      if (this.heartbeatTimer) {
        clearInterval(this.heartbeatTimer);
        this.heartbeatTimer = null;
      }
    },

    updateFromData(data) {
      if (data.docs_imported !== undefined) this.docsImported = data.docs_imported;
      if (data.docs_merged !== undefined) this.docsMerged = data.docs_merged;
      if (data.items_total !== undefined) this.itemsTotal = data.items_total;
      if (data.chunks_created !== undefined) this.chunksCreated = data.chunks_created;
      if (data.docs_processed !== undefined) this.docsProcessed = data.docs_processed;
      if (data.docs_total !== undefined) this.docsToChunk = data.docs_total;
      if (data.chunks_embedded !== undefined) this.chunksEmbedded = data.chunks_embedded;
      if (data.chunks_total !== undefined) this.chunksTotal = data.chunks_total;
      if (data.pending_chunks !== undefined) this.chunksTotal = data.pending_chunks;
      if (data.tokens_used !== undefined) this.tokensUsed = data.tokens_used;
      if (data.cost_usd !== undefined) this.costUsd = data.cost_usd;
    },

    async pauseSync() {
      try {
        await fetch(`/api/sync/${this.jobId}/pause`, { method: 'POST' });
      } catch (e) {
        console.error('Pause error:', e);
      }
    },

    async cancelSync() {
      try {
        await fetch(`/api/sync/${this.jobId}/cancel`, { method: 'POST' });
        this.status = 'cancelled';
        if (this.eventSource) {
          this.eventSource.close();
        }
      } catch (e) {
        console.error('Cancel error:', e);
      }
    },

    async resumeSync() {
      this.status = 'running';
      this.connectStream();
    },

    resetState() {
      this.stopHeartbeatMonitor();
      this.status = 'idle';
      this.phase = 'idle';
      this.jobId = null;
      this.docsImported = 0;
      this.docsMerged = 0;
      this.chunksCreated = 0;
      this.docsProcessed = 0;
      this.docsToChunk = 0;
      this.chunksEmbedded = 0;
      this.chunksTotal = 0;
      this.tokensUsed = 0;
      this.costUsd = 0;
      this.itemsTotal = 0;
      this.currentActivity = '';
      this.error = null;
      this.log = [];
      this.lastHeartbeat = null;
    },

    resetSync() {
      this.resetState();
      this.refreshStats();
    },

    async refreshStats() {
      try {
        const res = await fetch('/api/sync/stats');
        this.stats = await res.json();
      } catch (e) {
        console.error('Stats refresh error:', e);
      }
    },

    addLog(level, message) {
      const now = new Date();
      const time = now.toLocaleTimeString('de-DE');
      this.log.push({ time, level, message });
    }
  };
}
</script>

{% endblock %}
